---
layout:     post
title:      "List<E>.remove()无效"
subtitle:   "今天做购物车数量加减功能时候 对购物车List集合进行操作时报错！"
date:       2017-02-26
author:     "Binux"
header-img: "img/in-post/List.remove()/blog.png"
catalog: true
tags:
    - Java
    - Bug
    - XBin-Store
---

> “还是接触Java太少了，以前根本没碰到过，记录下这个小问题”


## 前言

今天做到购物车功能 写JS写到想吐 还是感觉Java简单点 前端对于我来说还是个弱点 我就用笨办法实现 用JQuery一个一个选择 终于完成了基本的功能

在做购物车商品加减时 网页用JS加减同时向服务器发送AJax加减数量 由于使用的分布式架构 购物车商品不能存在Session中 就选择存储在Redis中 每次都去数据遍历 购物车东西少还可以 一旦商品多了 感觉太浪费性能了

然后就想着有没有办法可以不用每次遍历整个购物车List集合 然后就想到从页面传入一个索引值 直接定位List中需要加减的商品 于是就引发了这个问题

[不想看我BB的 直接跳到最后看总结 ](#build)

---

## 正文

<img class="shadow" src="/img/in-post/List.remove()/cart.png" />
<small class="img-hint">购物车截图</small>

服务端代码：
```Java
/**
 *
 * 根据商品id和数量对购物车增加商品或减少商品
 *
 * @param pid       商品id
 * @param pcount    增加数量
 * @param type      1 增加 2 减少
 * @param index     商品位置   ps:用于直接定位商品 不用遍历整个购物车
 * @return
 */
@Override
public XbinResult decreOrIncre(Long pid, Integer pcount, Integer type, Integer index, String cookieUUID) {

    String key = CART_INFO_PROFIX + cookieUUID;

    List<CartInfo> cartInfoList = getCartInfoListByCookiesId(cookieUUID);
    if (cartInfoList == null || cartInfoList.size() == 0) {
        return XbinResult.build(400, "购物车没有商品 请不要非法操作!");
    }

    CartInfo cartInfo = cartInfoList.get(index);

    if (type == 1) {
        cartInfo.setNum(cartInfo.getNum() + pcount);
    } else {
        cartInfo.setNum(cartInfo.getNum() - pcount);
    }
    cartInfoList.remove(index);
    cartInfoList.add(index, cartInfo);
    jedisClient.set(key, FastJsonConvert.convertObjectToJSON(cartInfoList));
    jedisClient.expire(key,REDIS_CART_EXPIRE_TIME);

    return XbinResult.ok();
}
```
> 代码就不解释了 太简单了。


点击➕一件商品 然后就出现了一个非常奇怪的现象 商品确实加1了 但是出现了2个相同的商品
<img class="shadow" src="/img/in-post/List.remove()/Bug.png" />
<small class="img-hint">点击➕号后刷新出现</small>

查询Redis中数据是这样的

```Json
[
  {
    "colour": "黑色",
    "id": 148630831972863,
    "imageUrl": "http://192.168.125.132/group1/M00/00/00/wKh9hFiM0l-AQuvEAABmx7u5QSA128.jpg",
    "name": "Apple MacBook Pro 15.4英寸笔记本电脑 深空灰色（Multi-Touch Bar/Core i7/16GB/512GB MLH42CH/A）",
    "num": 3,
    "price": 2148800,
    "size": "32GB",
    "sum": 6446400
  },
  {
    "$ref": "$[0]"
  },
  {
    "colour": "黑色",
    "id": 148630639229938,
    "imageUrl": "http://192.168.125.132/group1/M00/00/00/wKh9hFiMy4eAV5lwAAB25IS6WjM274.jpg",
    "name": "Apple iPhone 7 (A1660) 32G 黑色 移动联通电信4G手机",
    "num": 2,
    "price": 519900,
    "size": "32GB",
    "sum": 1039800
  }
]
```
> "$ref": "$[0]" 表示数据引用索引0位置的数据

List.remove()无效 无效第一时间想到的是查查看API是不是我用错了
<img class="shadow" src="/img/in-post/List.remove()/api.png" />
<small class="img-hint">int remove(int index)</small>

API并没有用错 但为什么就是remove不掉呢！ 然后就DEBUG查看了下整个流程

<img class="shadow" src="/img/in-post/List.remove()/DEBUG1.png" />
<small class="img-hint">从Redis中取出的购物车List</small>

<img class="shadow" src="/img/in-post/List.remove()/DEBUG2.png" />
<small class="img-hint">List.get(index)得到对象</small>

发现问题了 **内存地址竟然一样一样！！！**

这才想起来 我把CartInfo类给序列化了 **脑中万\*\*马奔腾** 不是我没事去实现Serializable接口 而是Dubbox传输的对象 不实现Serializable就报错

但是也说不通啊 为什么我Remove不掉呢 我只想保留一个

在次查询API 发现问题了 remove()有重载方法

<img class="shadow" src="/img/in-post/List.remove()/Bug2.png" />
<small class="img-hint">boolean remove(Object o)</small>

......

我定义的Integer index ，他竟然没有自动拆箱 当成对象去比较了 这两个对象当然不会相同 返回false 自然不会删除 

应该是默认调用的boolean remove(Object o) 方法才没有拆箱

<p id = "build"></p>
---

## 总结

List Remove对象时不要传Integer对象的index值 要传也只能是传index.intValue()；

```Java
//cartInfoList.remove(index);
//cartInfoList.add(index, cartInfo);
```
最后我直接把这两句全注释了 解决了问题。

## 著作权声明

本文首次发布于 [Binux Blog](http://binux.cn)，转载请保留以上链接
